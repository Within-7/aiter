# AiTer è¯­éŸ³è¾“å…¥åŠŸèƒ½è®¾è®¡æ–¹æ¡ˆ

## æ¦‚è¿°

ä¸º AiTer æ·»åŠ ç°ä»£åŒ–çš„è¯­éŸ³è¾“å…¥åŠŸèƒ½ï¼Œè®©ç”¨æˆ·å¯ä»¥é€šè¿‡è¯­éŸ³ä¸ AI CLI å·¥å…·å’Œæ–‡ä»¶ç¼–è¾‘å™¨è¿›è¡Œäº¤äº’ã€‚

## è®¾è®¡ç›®æ ‡

1. **æ— ç¼é›†æˆ** - è¯­éŸ³è¾“å…¥ä½œä¸ºç°æœ‰è¾“å…¥æ–¹å¼çš„è¡¥å……ï¼Œä¸æ”¹å˜ç”¨æˆ·ä¹ æƒ¯
2. **å¤šåœºæ™¯æ”¯æŒ** - åŒæ—¶æ”¯æŒç»ˆç«¯å‘½ä»¤è¾“å…¥ã€ä»£ç ç¼–è¾‘ã€æ–‡æ¡£æ’°å†™
3. **å®æ—¶è½¬å½•** - è¾¹è¯´è¾¹æ˜¾ç¤ºï¼Œæµå¼è¯†åˆ«ç»“æœ
4. **åŒå¼•æ“æ”¯æŒ** - ç³»ç»ŸåŸç”Ÿï¼ˆç¦»çº¿ï¼‰+ Qwen-ASRï¼ˆäº‘ç«¯é«˜ç²¾åº¦ï¼‰
5. **éšç§ä¼˜å…ˆ** - é»˜è®¤ä½¿ç”¨ç³»ç»ŸåŸç”Ÿç¦»çº¿è¯†åˆ«

---

## è¯­éŸ³è¯†åˆ«å¼•æ“

### å¼•æ“å¯¹æ¯”

| ç‰¹æ€§ | ç³»ç»ŸåŸç”Ÿ | Qwen-ASR |
|------|----------|----------|
| **å®æ—¶æ€§** | âœ… æµå¼è¯†åˆ« | âœ… æµå¼è¯†åˆ« |
| **ç¦»çº¿æ”¯æŒ** | âœ… å®Œå…¨ç¦»çº¿ | âŒ éœ€è¦ç½‘ç»œ |
| **ä¸­æ–‡å‡†ç¡®åº¦** | è‰¯å¥½ | ä¼˜ç§€ |
| **æŠ€æœ¯æœ¯è¯­** | ä¸€èˆ¬ | ä¼˜ç§€ |
| **è´¹ç”¨** | å…è´¹ | æœ‰å…è´¹é¢åº¦ |
| **é…ç½®éš¾åº¦** | é›¶é…ç½® | éœ€è¦ API Key |
| **éšç§** | âœ… æœ¬åœ°å¤„ç† | âš ï¸ äº‘ç«¯å¤„ç† |

### æ¨èä½¿ç”¨åœºæ™¯

- **ç³»ç»ŸåŸç”Ÿ**ï¼šæ—¥å¸¸ä½¿ç”¨ã€éšç§æ•æ„Ÿåœºæ™¯ã€æ— ç½‘ç»œç¯å¢ƒ
- **Qwen-ASR**ï¼šéœ€è¦é«˜ç²¾åº¦è¯†åˆ«ã€æŠ€æœ¯æœ¯è¯­è¾ƒå¤šã€ç¼–ç¨‹ç›¸å…³è¾“å…¥

---

## äº¤äº’è®¾è®¡

### 1. æ¿€æ´»æ–¹å¼

#### 1.1 æŒ‰ä½è¯´è¯ (Push-to-Talk) - æ¨èæ–¹å¼

```
é»˜è®¤æŒ‰é”®: Option (macOS) / Alt (Windows)
```

**äº¤äº’æµç¨‹ï¼š**
```
æŒ‰ä¸‹ Option â”€â”€â†’ å¼€å§‹å½•éŸ³ â”€â”€â†’ è¯´è¯ï¼ˆå®æ—¶æ˜¾ç¤ºæ–‡å­—ï¼‰â”€â”€â†’ æ¾å¼€ Option â”€â”€â†’ æ’å…¥æ–‡æœ¬
     â”‚                              â”‚                        â”‚
     â””â”€â”€ æ˜¾ç¤ºå½•éŸ³æŒ‡ç¤ºå™¨              â””â”€â”€ æµå¼æ›´æ–°è¯†åˆ«ç»“æœ      â””â”€â”€ éšè—æŒ‡ç¤ºå™¨
```

**ä¸ºä»€ä¹ˆé€‰æ‹© Option/Alt é”®ï¼Ÿ**
- âœ… å•é”®æ“ä½œï¼Œæ¯”ç»„åˆé”®æ›´è‡ªç„¶
- âœ… ä½ç½®é€‚åˆæ‹‡æŒ‡æŒ‰å‹ï¼Œç¬¦åˆäººä½“å·¥å­¦
- âœ… åœ¨ç»ˆç«¯å’Œç¼–è¾‘å™¨ä¸­å¾ˆå°‘å•ç‹¬ä½¿ç”¨
- âœ… ç±»ä¼¼å¯¹è®²æœºçš„ç›´è§‰æ“ä½œ

**é˜²è¯¯è§¦æœºåˆ¶ï¼š**
- éœ€æŒ‰ä½è¶…è¿‡ 200ms æ‰å¼€å§‹å½•éŸ³ï¼ˆé¿å…è¯¯è§¦ï¼‰
- æŒ‰ä½æ—¶é—´å°‘äº 500ms ä¸”æ— è¯­éŸ³æ£€æµ‹æ—¶ï¼Œä¸è§¦å‘è¯†åˆ«
- å¦‚æœç„¦ç‚¹åœ¨éœ€è¦ Option çš„è¾“å…¥æ¡†ä¸­ï¼Œè‡ªåŠ¨ç¦ç”¨

**å¯é€‰æ›¿ä»£é”®ï¼š**
| æŒ‰é”® | macOS | Windows | è¯´æ˜ |
|------|-------|---------|------|
| Option/Alt | âŒ¥ | Alt | é»˜è®¤æ¨è |
| Fn | Fn | Fn | æ›´ä¸å®¹æ˜“è¯¯è§¦ |
| å³ Command | âŒ˜ (å³) | å³ Ctrl | é€‚åˆå³æ‰‹æ“ä½œ |
| è‡ªå®šä¹‰ | ç”¨æˆ·è®¾ç½® | ç”¨æˆ·è®¾ç½® | ä»»æ„å•é”®æˆ–ç»„åˆé”® |

#### 1.2 åˆ‡æ¢æ¨¡å¼ï¼ˆå¯é€‰ï¼‰

```
å¿«æ·é”®: Cmd+Shift+V (macOS) / Ctrl+Shift+V (Windows)
```

- æŒ‰ä¸€æ¬¡å¼€å§‹å½•éŸ³
- å†æŒ‰ä¸€æ¬¡ç»“æŸå½•éŸ³
- é€‚åˆé•¿æ—¶é—´è¯­éŸ³è¾“å…¥åœºæ™¯

#### 1.3 UI æŒ‰é’®æ¿€æ´»ï¼ˆè¾…åŠ©æ–¹å¼ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [Tab1] [Tab2] [Tab3]              [ğŸ¤]  [âš™ï¸]        â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚                                                     â”‚
â”‚  Terminal / Editor Content                          â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- æ ‡ç­¾æ å³ä¾§æ·»åŠ éº¦å…‹é£æŒ‰é’®
- ç‚¹å‡»æ¿€æ´»/åœæ­¢è¯­éŸ³è¾“å…¥
- å½•éŸ³æ—¶æŒ‰é’®æ˜¾ç¤ºåŠ¨ç”»æ•ˆæœ

### 2. å®æ—¶è§†è§‰åé¦ˆ

#### 2.1 å½•éŸ³çŠ¶æ€æŒ‡ç¤ºå™¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚  ğŸ”´ æ­£åœ¨å½•éŸ³...  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘  [åœæ­¢]         â”‚   â”‚
â”‚ â”‚                                               â”‚   â”‚
â”‚ â”‚  "æˆ‘æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ React ç»„ä»¶"              â”‚   â”‚
â”‚ â”‚                          â–²                    â”‚   â”‚
â”‚ â”‚                     å®æ—¶æ›´æ–°                  â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                     â”‚
â”‚  $ npm run dev                                      â”‚
â”‚  > vite                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**çŠ¶æ€æŒ‡ç¤ºå™¨ç‰¹æ€§ï¼š**
- æµ®åŠ¨åœ¨å½“å‰æ´»åŠ¨åŒºåŸŸä¸Šæ–¹
- æ˜¾ç¤ºå½•éŸ³æ³¢å½¢/éŸ³é‡æ¡
- **å®æ—¶æ˜¾ç¤ºè¯†åˆ«ä¸­çš„æ–‡å­—ï¼ˆæµå¼æ›´æ–°ï¼‰**
- æä¾›æ‰‹åŠ¨åœæ­¢æŒ‰é’®
- æ˜¾ç¤ºå½“å‰ä½¿ç”¨çš„è¯†åˆ«å¼•æ“

#### 2.2 çŠ¶æ€å›¾æ ‡å˜åŒ–

| çŠ¶æ€ | å›¾æ ‡ | é¢œè‰² | æè¿° |
|------|------|------|------|
| å¾…æœº | ğŸ¤ | ç°è‰² | å¯ä»¥å¼€å§‹å½•éŸ³ |
| å½•éŸ³ä¸­ | ğŸ”´ | çº¢è‰²+è„‰åŠ¨åŠ¨ç”» | æ­£åœ¨å½•éŸ³å’Œè¯†åˆ« |
| å¤„ç†ä¸­ | â³ | é»„è‰² | æ­£åœ¨å¤„ç†æœ€ç»ˆç»“æœ |
| é”™è¯¯ | âš ï¸ | çº¢è‰² | è¯†åˆ«å¤±è´¥ |

### 3. æ–‡æœ¬æ’å…¥è¡Œä¸º

#### 3.1 ç»ˆç«¯æ¨¡å¼

```typescript
// è¯­éŸ³è¯†åˆ«å®Œæˆå
const insertToTerminal = (text: string, options: InsertOptions) => {
  // ä¸è‡ªåŠ¨æ‰§è¡Œï¼Œåªè¾“å…¥æ–‡æœ¬
  await window.api.terminal.write(activeTerminalId, text)

  // ç”¨æˆ·å¯é€‰ï¼šè‡ªåŠ¨æ·»åŠ æ¢è¡Œæ‰§è¡Œ
  if (options.autoExecute) {
    await window.api.terminal.write(activeTerminalId, '\n')
  }
}
```

**ç»ˆç«¯ä¸“ç”¨æŒ‡ä»¤è¯†åˆ«ï¼š**
- "æ‰§è¡Œ" / "è¿è¡Œ" / "å›è½¦" â†’ å‘é€æ¢è¡Œç¬¦
- "æ¸…ç©º" / "æ¸…é™¤" â†’ å‘é€ Ctrl+C æˆ–æ¸…ç©ºè¾“å…¥
- "ä¸Šä¸€æ¡" / "ä¸Šä¸€ä¸ªå‘½ä»¤" â†’ å‘é€å‘ä¸Šç®­å¤´

#### 3.2 ç¼–è¾‘å™¨æ¨¡å¼

```typescript
// è¯­éŸ³è¯†åˆ«å®Œæˆå
const insertToEditor = (text: string, options: InsertOptions) => {
  // è·å–å½“å‰å…‰æ ‡ä½ç½®
  const position = editor.getPosition()

  // æ’å…¥æ–‡æœ¬
  editor.executeEdits('voice-input', [{
    range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
    text: text
  }])
}
```

**ç¼–è¾‘å™¨ä¸“ç”¨æŒ‡ä»¤è¯†åˆ«ï¼š**
- "æ–°è¡Œ" / "æ¢è¡Œ" â†’ æ’å…¥æ¢è¡Œç¬¦
- "åˆ é™¤è¿™è¡Œ" â†’ åˆ é™¤å½“å‰è¡Œ
- "æ’¤é”€" â†’ è§¦å‘ Ctrl+Z

---

## æŠ€æœ¯æ¶æ„

### 1. åŒå¼•æ“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VoiceInputManager                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                  ç»Ÿä¸€æ¥å£å±‚                          â”‚    â”‚
â”‚  â”‚  start() | stop() | onInterimResult() | onFinal()   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                           â”‚                                  â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚              â–¼                         â–¼                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚    ç³»ç»ŸåŸç”Ÿå¼•æ“      â”‚   â”‚    Qwen-ASR å¼•æ“    â”‚         â”‚
â”‚  â”‚  (NativeSpeech)     â”‚   â”‚   (QwenASRService)  â”‚         â”‚
â”‚  â”‚                     â”‚   â”‚                     â”‚         â”‚
â”‚  â”‚  macOS: Speech      â”‚   â”‚  WebSocket å®æ—¶æµ   â”‚         â”‚
â”‚  â”‚  Framework          â”‚   â”‚  é˜¿é‡Œäº‘ DashScope   â”‚         â”‚
â”‚  â”‚                     â”‚   â”‚                     â”‚         â”‚
â”‚  â”‚  Windows: SAPI /    â”‚   â”‚  æ”¯æŒ VAD è‡ªåŠ¨æ–­å¥  â”‚         â”‚
â”‚  â”‚  WinRT Speech       â”‚   â”‚                     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                           â”‚                       â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                     â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              å®æ—¶ç»“æœå›è°ƒ                            â”‚   â”‚
â”‚  â”‚  onInterimResult(text) â†’ æ›´æ–° UI æ˜¾ç¤º               â”‚   â”‚
â”‚  â”‚  onFinalResult(text) â†’ æ’å…¥åˆ°ç»ˆç«¯/ç¼–è¾‘å™¨            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ•°æ®æµ

```
ç”¨æˆ·æŒ‰ä½ Option é”®
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  éº¦å…‹é£é‡‡é›†  â”‚  (navigator.mediaDevices.getUserMedia)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç³»ç»ŸåŸç”Ÿ    â”‚      æˆ–         â”‚  Qwen-ASR   â”‚
â”‚  Speech API â”‚                  â”‚  WebSocket  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚                                     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  å®æ—¶ç»“æœ    â”‚  (onInterimResult)
         â”‚  æ›´æ–° UI    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
    ç”¨æˆ·æ¾å¼€ Option é”®
                  â”‚
                  â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  æœ€ç»ˆç»“æœ    â”‚  (onFinalResult)
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼             â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Terminal â”‚ â”‚ Editor  â”‚ â”‚ Search  â”‚
â”‚  Input  â”‚ â”‚  Input  â”‚ â”‚  Input  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å¼•æ“å®ç°

### 1. ç³»ç»ŸåŸç”Ÿå¼•æ“

#### macOS: Speech Framework

```typescript
// src/main/services/NativeSpeechMac.ts
// é€šè¿‡ Native Module è°ƒç”¨ macOS Speech Framework

import { NativeModules } from 'electron'

export class NativeSpeechMac implements VoiceRecognitionService {
  private recognizer: any  // Native binding

  async start(options: RecognitionOptions): Promise<void> {
    // è°ƒç”¨ Objective-C ç»‘å®š
    await NativeModules.SpeechRecognizer.start({
      language: options.language,  // 'zh-CN'
      onDeviceRecognition: true,   // å¼ºåˆ¶ç¦»çº¿è¯†åˆ«
      reportPartialResults: true   // å¯ç”¨å®æ—¶ç»“æœ
    })
  }

  stop(): void {
    NativeModules.SpeechRecognizer.stop()
  }

  onInterimResult(callback: (text: string) => void): void {
    NativeModules.SpeechRecognizer.onPartialResult(callback)
  }

  onFinalResult(callback: (text: string) => void): void {
    NativeModules.SpeechRecognizer.onFinalResult(callback)
  }
}
```

**macOS Native Module (Objective-C):**
```objective-c
// native/macos/SpeechRecognizer.mm
#import <Speech/Speech.h>

@implementation SpeechRecognizer

- (void)startWithLanguage:(NSString *)language
           onPartialResult:(void (^)(NSString *))partialCallback
            onFinalResult:(void (^)(NSString *))finalCallback {

    SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc]
        initWithLocale:[NSLocale localeWithLocaleIdentifier:language]];

    // æ£€æŸ¥å¹¶å¯ç”¨ç¦»çº¿è¯†åˆ«
    if (recognizer.supportsOnDeviceRecognition) {
        self.request.requiresOnDeviceRecognition = YES;
    }

    self.request.shouldReportPartialResults = YES;  // å®æ—¶ç»“æœ

    [recognizer recognitionTaskWithRequest:self.request
        resultHandler:^(SFSpeechRecognitionResult *result, NSError *error) {
            if (result) {
                NSString *text = result.bestTranscription.formattedString;
                if (result.isFinal) {
                    finalCallback(text);
                } else {
                    partialCallback(text);  // å®æ—¶ä¸­é—´ç»“æœ
                }
            }
        }];
}

@end
```

#### Windows: WinRT Speech API

```typescript
// src/main/services/NativeSpeechWindows.ts

export class NativeSpeechWindows implements VoiceRecognitionService {
  private recognizer: any  // WinRT binding

  async start(options: RecognitionOptions): Promise<void> {
    // è°ƒç”¨ Windows Runtime Speech API
    await NativeModules.WindowsSpeech.start({
      language: options.language,
      continuousRecognition: true,
      onlineMode: false  // ç¦»çº¿æ¨¡å¼
    })
  }

  // ... ç±»ä¼¼å®ç°
}
```

### 2. Qwen-ASR å¼•æ“

```typescript
// src/renderer/services/QwenASRService.ts

interface QwenASROptions {
  apiKey: string
  language?: string
  onInterimResult: (text: string) => void
  onFinalResult: (text: string) => void
  onError: (error: string) => void
}

export class QwenASRService implements VoiceRecognitionService {
  private ws: WebSocket | null = null
  private audioContext: AudioContext | null = null
  private mediaStream: MediaStream | null = null
  private processor: ScriptProcessorNode | null = null
  private isRunning = false
  private accumulatedText = ''

  private readonly baseUrl = 'wss://dashscope.aliyuncs.com/api-ws/v1/realtime'
  private readonly model = 'qwen2-audio-asr-realtime'

  constructor(private options: QwenASROptions) {}

  async start(): Promise<void> {
    this.isRunning = true
    this.accumulatedText = ''

    // 1. å»ºç«‹ WebSocket è¿æ¥
    const url = `${this.baseUrl}?model=${this.model}`
    this.ws = new WebSocket(url)

    // è®¾ç½®é‰´æƒå¤´ï¼ˆé€šè¿‡ URL å‚æ•°æˆ–åœ¨ open åå‘é€ï¼‰
    this.ws.onopen = () => {
      this.sendAuth()
      this.sendSessionUpdate()
      this.startAudioCapture()
    }

    this.ws.onmessage = (event) => {
      this.handleMessage(JSON.parse(event.data))
    }

    this.ws.onerror = (err) => {
      this.options.onError(`WebSocket é”™è¯¯: ${err}`)
    }

    this.ws.onclose = () => {
      this.cleanup()
    }
  }

  stop(): void {
    this.isRunning = false

    // å‘é€ç»“æŸä¿¡å·
    if (this.ws?.readyState === WebSocket.OPEN) {
      const commitEvent = {
        event_id: `event_${Date.now()}`,
        type: 'input_audio_buffer.commit'
      }
      this.ws.send(JSON.stringify(commitEvent))
    }
  }

  private sendAuth(): void {
    // å‘é€é‰´æƒä¿¡æ¯
    const authEvent = {
      event_id: 'event_auth',
      type: 'auth',
      auth: {
        api_key: this.options.apiKey
      }
    }
    this.ws?.send(JSON.stringify(authEvent))
  }

  private sendSessionUpdate(): void {
    const sessionConfig = {
      event_id: 'event_session',
      type: 'session.update',
      session: {
        modalities: ['text'],
        input_audio_format: 'pcm',
        sample_rate: 16000,
        input_audio_transcription: {
          language: this.options.language || 'zh'
        },
        // ä½¿ç”¨ VAD æ¨¡å¼è‡ªåŠ¨æ–­å¥
        turn_detection: {
          type: 'server_vad',
          threshold: 0.5,
          silence_duration_ms: 500
        }
      }
    }
    this.ws?.send(JSON.stringify(sessionConfig))
  }

  private async startAudioCapture(): Promise<void> {
    // è·å–éº¦å…‹é£
    this.mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true
      }
    })

    this.audioContext = new AudioContext({ sampleRate: 16000 })
    const source = this.audioContext.createMediaStreamSource(this.mediaStream)

    // ä½¿ç”¨ ScriptProcessor è·å– PCM æ•°æ®
    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1)

    this.processor.onaudioprocess = (event) => {
      if (!this.isRunning || this.ws?.readyState !== WebSocket.OPEN) return

      const inputData = event.inputBuffer.getChannelData(0)
      const pcm16 = this.floatTo16BitPCM(inputData)
      const base64Audio = this.arrayBufferToBase64(pcm16.buffer)

      // å‘é€éŸ³é¢‘æ•°æ®
      const appendEvent = {
        event_id: `event_${Date.now()}`,
        type: 'input_audio_buffer.append',
        audio: base64Audio
      }
      this.ws?.send(JSON.stringify(appendEvent))
    }

    source.connect(this.processor)
    this.processor.connect(this.audioContext.destination)
  }

  private handleMessage(data: any): void {
    switch (data.type) {
      // å®æ—¶ä¸­é—´ç»“æœï¼ˆå¢é‡ï¼‰
      case 'conversation.item.input_audio_transcription.delta':
        if (data.delta) {
          this.accumulatedText += data.delta
          this.options.onInterimResult(this.accumulatedText)
        }
        break

      // æœ€ç»ˆç»“æœ
      case 'conversation.item.input_audio_transcription.completed':
        if (data.transcript) {
          this.options.onFinalResult(data.transcript)
        }
        break

      case 'error':
        this.options.onError(data.error?.message || 'è¯†åˆ«é”™è¯¯')
        break
    }
  }

  private floatTo16BitPCM(float32Array: Float32Array): Int16Array {
    const int16Array = new Int16Array(float32Array.length)
    for (let i = 0; i < float32Array.length; i++) {
      const s = Math.max(-1, Math.min(1, float32Array[i]))
      int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF
    }
    return int16Array
  }

  private arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer)
    let binary = ''
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i])
    }
    return btoa(binary)
  }

  private cleanup(): void {
    this.processor?.disconnect()
    this.mediaStream?.getTracks().forEach(track => track.stop())
    this.audioContext?.close()
    this.ws = null
    this.isRunning = false
  }
}
```

### 3. ç»Ÿä¸€ç®¡ç†å™¨

```typescript
// src/renderer/services/VoiceInputManager.ts

type VoiceProvider = 'system' | 'qwen-asr'

interface VoiceInputManagerOptions {
  provider: VoiceProvider
  language: string
  qwenApiKey?: string
  onInterimResult: (text: string) => void
  onFinalResult: (text: string) => void
  onError: (error: string) => void
  onStateChange: (state: VoiceInputState) => void
}

export class VoiceInputManager {
  private service: VoiceRecognitionService | null = null
  private options: VoiceInputManagerOptions

  constructor(options: VoiceInputManagerOptions) {
    this.options = options
    this.initService()
  }

  private initService(): void {
    const { provider, language, qwenApiKey } = this.options

    if (provider === 'system') {
      // æ ¹æ®å¹³å°é€‰æ‹©ç³»ç»ŸåŸç”Ÿå¼•æ“
      if (process.platform === 'darwin') {
        this.service = new NativeSpeechMac()
      } else if (process.platform === 'win32') {
        this.service = new NativeSpeechWindows()
      }
    } else if (provider === 'qwen-asr') {
      if (!qwenApiKey) {
        this.options.onError('Qwen-ASR éœ€è¦é…ç½® API Key')
        return
      }
      this.service = new QwenASRService({
        apiKey: qwenApiKey,
        language,
        onInterimResult: this.options.onInterimResult,
        onFinalResult: this.options.onFinalResult,
        onError: this.options.onError
      })
    }
  }

  async start(): Promise<void> {
    if (!this.service) {
      this.options.onError('è¯­éŸ³è¯†åˆ«æœåŠ¡æœªåˆå§‹åŒ–')
      return
    }

    this.options.onStateChange('recording')
    await this.service.start({
      language: this.options.language
    })
  }

  stop(): void {
    this.options.onStateChange('processing')
    this.service?.stop()
  }

  // åˆ‡æ¢å¼•æ“
  switchProvider(provider: VoiceProvider): void {
    this.options.provider = provider
    this.initService()
  }
}
```

---

## æ–‡ä»¶ç»“æ„

```
src/
â”œâ”€â”€ main/
â”‚   â”œâ”€â”€ ipc/
â”‚   â”‚   â””â”€â”€ voiceInput.ts              # IPC å¤„ç†
â”‚   â””â”€â”€ services/
â”‚       â”œâ”€â”€ NativeSpeechMac.ts         # macOS åŸç”Ÿè¯­éŸ³
â”‚       â””â”€â”€ NativeSpeechWindows.ts     # Windows åŸç”Ÿè¯­éŸ³
â”‚
â”œâ”€â”€ renderer/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ VoiceInputManager.ts       # è¯­éŸ³è¾“å…¥ç»Ÿä¸€ç®¡ç†å™¨
â”‚   â”‚   â””â”€â”€ QwenASRService.ts          # Qwen-ASR å®ç°
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ VoiceInput/
â”‚   â”‚   â”‚   â”œâ”€â”€ VoiceInputButton.tsx       # éº¦å…‹é£æŒ‰é’®
â”‚   â”‚   â”‚   â”œâ”€â”€ VoiceInputIndicator.tsx    # å½•éŸ³çŠ¶æ€æŒ‡ç¤ºå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ VoiceInputOverlay.tsx      # æµ®åŠ¨å½•éŸ³é¢æ¿
â”‚   â”‚   â”‚   â””â”€â”€ VoiceWaveform.tsx          # éŸ³é‡æ³¢å½¢æ˜¾ç¤º
â”‚   â”‚   â””â”€â”€ Settings/
â”‚   â”‚       â””â”€â”€ VoiceInputSettings.tsx     # è¯­éŸ³è®¾ç½®é¢æ¿
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ usePushToTalk.ts           # Push-to-Talk Hook
â”‚   â”‚   â””â”€â”€ useVoiceInput.ts           # è¯­éŸ³è¾“å…¥ Hook
â”‚   â”‚
â”‚   â””â”€â”€ context/
â”‚       â””â”€â”€ VoiceInputContext.tsx      # è¯­éŸ³è¾“å…¥çŠ¶æ€ç®¡ç†
â”‚
â”œâ”€â”€ native/
â”‚   â”œâ”€â”€ macos/
â”‚   â”‚   â””â”€â”€ SpeechRecognizer.mm        # macOS Native Module
â”‚   â””â”€â”€ windows/
â”‚       â””â”€â”€ SpeechRecognizer.cpp       # Windows Native Module
â”‚
â””â”€â”€ types/
    â””â”€â”€ voiceInput.ts                  # TypeScript ç±»å‹å®šä¹‰
```

---

## è®¾ç½®é¡¹

### TypeScript ç±»å‹å®šä¹‰

```typescript
// src/types/voiceInput.ts

type VoiceProvider = 'system' | 'qwen-asr'

interface VoiceInputSettings {
  // åŸºç¡€è®¾ç½®
  enabled: boolean                    // æ˜¯å¦å¯ç”¨è¯­éŸ³è¾“å…¥
  provider: VoiceProvider             // è¯†åˆ«å¼•æ“

  // Push-to-Talk è®¾ç½®
  pushToTalk: {
    enabled: boolean                  // å¯ç”¨æŒ‰ä½è¯´è¯
    triggerKey: 'Alt' | 'Meta' | 'Control' | 'Fn' | string
    minHoldDuration: number           // æœ€å°æŒ‰ä½æ—¶é—´ï¼ˆmsï¼‰ï¼Œé»˜è®¤ 200
  }

  // åˆ‡æ¢æ¨¡å¼è®¾ç½®ï¼ˆå¤‡é€‰ï¼‰
  toggleMode: {
    enabled: boolean                  // å¯ç”¨åˆ‡æ¢æ¨¡å¼
    shortcut: KeyboardShortcut        // Cmd+Shift+V
  }

  // è¯†åˆ«è®¾ç½®
  language: string                    // 'zh-CN', 'en-US', 'auto'
  interimResults: boolean             // æ˜¾ç¤ºå®æ—¶ç»“æœ

  // è¡Œä¸ºè®¾ç½®
  autoExecuteInTerminal: boolean      // ç»ˆç«¯ä¸­è‡ªåŠ¨æ‰§è¡Œï¼ˆæŒ‰å›è½¦ï¼‰
  insertMode: 'cursor' | 'newline'    // æ’å…¥ä½ç½®
  enableVoiceCommands: boolean        // å¯ç”¨è¯­éŸ³æŒ‡ä»¤

  // Qwen-ASR è®¾ç½®
  qwenApiKey?: string                 // API Key
  qwenRegion?: 'cn' | 'intl'          // åŒºåŸŸï¼ˆä¸­å›½/å›½é™…ï¼‰

  // é«˜çº§è®¾ç½®
  customVocabulary?: Record<string, string[]>  // è‡ªå®šä¹‰æœ¯è¯­
  silenceTimeout: number              // é™éŸ³è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
}
```

### è®¾ç½® UI å¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è¯­éŸ³è¾“å…¥è®¾ç½®                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚ å¯ç”¨è¯­éŸ³è¾“å…¥              [å¼€å…³]                    â”‚
â”‚                                                     â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚                                                     â”‚
â”‚ è¯†åˆ«å¼•æ“                                            â”‚
â”‚                                                     â”‚
â”‚ â— ç³»ç»ŸåŸç”Ÿ (æ¨è)                                   â”‚
â”‚   â”” å®Œå…¨ç¦»çº¿ï¼Œå…è´¹ï¼Œæ— éœ€é…ç½®                        â”‚
â”‚   â”” macOS: Speech Framework                         â”‚
â”‚   â”” Windows: Windows Speech Recognition             â”‚
â”‚                                                     â”‚
â”‚ â—‹ é˜¿é‡Œäº‘ Qwen-ASR                                   â”‚
â”‚   â”” äº‘ç«¯è¯†åˆ«ï¼Œé«˜ç²¾åº¦ï¼Œé€‚åˆæŠ€æœ¯æœ¯è¯­                  â”‚
â”‚   API Key    [________________________] [è·å– â†—]    â”‚
â”‚   åŒºåŸŸ       [ä¸­å›½ (cn)            â–¼]               â”‚
â”‚                                                     â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚                                                     â”‚
â”‚ æ¿€æ´»æ–¹å¼                                            â”‚
â”‚                                                     â”‚
â”‚ â˜‘ æŒ‰ä½è¯´è¯ (Push-to-Talk)                          â”‚
â”‚   è§¦å‘é”®                   [Option/Alt     â–¼]       â”‚
â”‚   æœ€å°æŒ‰ä½æ—¶é—´             [200ms          â–¼]       â”‚
â”‚                                                     â”‚
â”‚ â–¡ åˆ‡æ¢æ¨¡å¼                                          â”‚
â”‚   å¿«æ·é”®                   [Cmd+Shift+V] [ä¿®æ”¹]     â”‚
â”‚                                                     â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚                                                     â”‚
â”‚ è¯†åˆ«è¯­è¨€                   [ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰    â–¼]      â”‚
â”‚                                                     â”‚
â”‚ â–¡ åœ¨ç»ˆç«¯ä¸­è‡ªåŠ¨æ‰§è¡Œå‘½ä»¤                              â”‚
â”‚ â˜‘ æ˜¾ç¤ºå®æ—¶è¯†åˆ«ç»“æœ                                  â”‚
â”‚ â˜‘ å¯ç”¨è¯­éŸ³æŒ‡ä»¤ï¼ˆå¦‚"æ‰§è¡Œ"ã€"æ¢è¡Œ"ï¼‰                 â”‚
â”‚                                                     â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚                                                     â”‚
â”‚ æç¤ºï¼šæŒ‰ä½ Option é”®è¯´è¯ï¼Œæ¾å¼€åè‡ªåŠ¨è¾“å…¥æ–‡å­—        â”‚
â”‚       å½“å‰å¼•æ“ï¼šç³»ç»ŸåŸç”Ÿï¼ˆç¦»çº¿ï¼‰                    â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å®ç°é˜¶æ®µ

### Phase 1: åŸºç¡€åŠŸèƒ½ï¼ˆMVPï¼‰
- [ ] Push-to-Talk æŒ‰é”®ç›‘å¬
- [ ] ç³»ç»ŸåŸç”Ÿå¼•æ“ï¼ˆmacOSï¼‰
- [ ] ç³»ç»ŸåŸç”Ÿå¼•æ“ï¼ˆWindowsï¼‰
- [ ] åŸºç¡€ UI æŒ‡ç¤ºå™¨
- [ ] ç»ˆç«¯æ–‡æœ¬è¾“å…¥
- [ ] è®¾ç½®é¢æ¿

### Phase 2: Qwen-ASR é›†æˆ
- [ ] Qwen-ASR WebSocket å®¢æˆ·ç«¯
- [ ] API Key é…ç½®å’ŒéªŒè¯
- [ ] å¼•æ“åˆ‡æ¢åŠŸèƒ½
- [ ] å®æ—¶æµå¼æ˜¾ç¤º

### Phase 3: å¢å¼ºä½“éªŒ
- [ ] ç¼–è¾‘å™¨é›†æˆ
- [ ] è¯­éŸ³æŒ‡ä»¤æ”¯æŒ
- [ ] å¤šè¯­è¨€åˆ‡æ¢
- [ ] éŸ³é‡æ³¢å½¢æ˜¾ç¤º

### Phase 4: å®Œå–„ä¼˜åŒ–
- [ ] è‡ªå®šä¹‰æœ¯è¯­è¡¨
- [ ] é”™è¯¯å¤„ç†ä¼˜åŒ–
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] å®Œæ•´æµ‹è¯•

---

## æŠ€æœ¯ç»†èŠ‚

### 1. Push-to-Talk æŒ‰é”®ç›‘å¬å®ç°

```typescript
// src/renderer/hooks/usePushToTalk.ts
import { useEffect, useRef, useCallback } from 'react'

interface PushToTalkOptions {
  triggerKey: string           // 'Alt', 'Meta', 'Fn' ç­‰
  minHoldDuration: number      // æœ€å°æŒ‰ä½æ—¶é—´ï¼ˆmsï¼‰ï¼Œé˜²è¯¯è§¦
  onStart: () => void          // å¼€å§‹å½•éŸ³å›è°ƒ
  onEnd: () => void            // ç»“æŸå½•éŸ³å›è°ƒ
  enabled: boolean             // æ˜¯å¦å¯ç”¨
}

export function usePushToTalk(options: PushToTalkOptions) {
  const {
    triggerKey = 'Alt',
    minHoldDuration = 200,
    onStart,
    onEnd,
    enabled = true
  } = options

  const isHolding = useRef(false)
  const holdStartTime = useRef<number | null>(null)
  const isRecording = useRef(false)
  const startTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    if (!enabled) return

    // æ£€æŸ¥æ˜¯å¦æ˜¯è§¦å‘é”®
    const isTriggerKey =
      (triggerKey === 'Alt' && event.altKey && event.key === 'Alt') ||
      (triggerKey === 'Meta' && event.metaKey && event.key === 'Meta') ||
      (triggerKey === 'Control' && event.ctrlKey && event.key === 'Control')

    if (!isTriggerKey) return

    // é˜²æ­¢é‡å¤è§¦å‘
    if (isHolding.current) return

    isHolding.current = true
    holdStartTime.current = Date.now()

    // å»¶è¿Ÿå¯åŠ¨å½•éŸ³ï¼ˆé˜²è¯¯è§¦ï¼‰
    startTimeoutRef.current = setTimeout(() => {
      if (isHolding.current && !isRecording.current) {
        isRecording.current = true
        onStart()
      }
    }, minHoldDuration)

  }, [triggerKey, minHoldDuration, onStart, enabled])

  const handleKeyUp = useCallback((event: KeyboardEvent) => {
    if (!enabled) return

    const isTriggerKey =
      (triggerKey === 'Alt' && event.key === 'Alt') ||
      (triggerKey === 'Meta' && event.key === 'Meta') ||
      (triggerKey === 'Control' && event.key === 'Control')

    if (!isTriggerKey) return

    // æ¸…é™¤å»¶è¿Ÿå¯åŠ¨çš„å®šæ—¶å™¨
    if (startTimeoutRef.current) {
      clearTimeout(startTimeoutRef.current)
      startTimeoutRef.current = null
    }

    isHolding.current = false
    holdStartTime.current = null

    // åªæœ‰åœ¨å®é™…å½•éŸ³çŠ¶æ€æ—¶æ‰è§¦å‘ç»“æŸ
    if (isRecording.current) {
      isRecording.current = false
      onEnd()
    }

  }, [triggerKey, onEnd, enabled])

  useEffect(() => {
    if (!enabled) return

    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)

    // å¤„ç†çª—å£å¤±ç„¦æ—¶çš„æƒ…å†µ
    const handleBlur = () => {
      if (startTimeoutRef.current) {
        clearTimeout(startTimeoutRef.current)
      }
      if (isRecording.current) {
        isRecording.current = false
        isHolding.current = false
        onEnd()
      }
    }
    window.addEventListener('blur', handleBlur)

    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
      window.removeEventListener('blur', handleBlur)
      if (startTimeoutRef.current) {
        clearTimeout(startTimeoutRef.current)
      }
    }
  }, [handleKeyDown, handleKeyUp, onEnd, enabled])
}
```

### 2. è¯­éŸ³è¾“å…¥ Hook

```typescript
// src/renderer/hooks/useVoiceInput.ts
import { useState, useRef, useCallback, useEffect } from 'react'
import { VoiceInputManager } from '../services/VoiceInputManager'
import { usePushToTalk } from './usePushToTalk'

export function useVoiceInput(settings: VoiceInputSettings) {
  const [isRecording, setIsRecording] = useState(false)
  const [interimText, setInterimText] = useState('')
  const [state, setState] = useState<'idle' | 'recording' | 'processing'>('idle')
  const managerRef = useRef<VoiceInputManager | null>(null)

  // åˆå§‹åŒ–ç®¡ç†å™¨
  useEffect(() => {
    managerRef.current = new VoiceInputManager({
      provider: settings.provider,
      language: settings.language,
      qwenApiKey: settings.qwenApiKey,
      onInterimResult: (text) => {
        setInterimText(text)
      },
      onFinalResult: (text) => {
        // æ’å…¥åˆ°å½“å‰ç„¦ç‚¹ä½ç½®
        insertTextToActiveInput(text)
        setInterimText('')
        setState('idle')
      },
      onError: (error) => {
        console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', error)
        setState('idle')
      },
      onStateChange: setState
    })

    return () => {
      managerRef.current = null
    }
  }, [settings.provider, settings.language, settings.qwenApiKey])

  const startRecording = useCallback(async () => {
    setIsRecording(true)
    setInterimText('')
    await managerRef.current?.start()
  }, [])

  const stopRecording = useCallback(() => {
    setIsRecording(false)
    managerRef.current?.stop()
  }, [])

  // Push-to-Talk é›†æˆ
  usePushToTalk({
    triggerKey: settings.pushToTalk.triggerKey,
    minHoldDuration: settings.pushToTalk.minHoldDuration,
    onStart: startRecording,
    onEnd: stopRecording,
    enabled: settings.enabled && settings.pushToTalk.enabled
  })

  return {
    isRecording,
    interimText,
    state,
    startRecording,
    stopRecording
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ’å…¥æ–‡æœ¬åˆ°å½“å‰ç„¦ç‚¹
function insertTextToActiveInput(text: string): void {
  const activeElement = document.activeElement

  // ç»ˆç«¯
  if (activeElement?.closest('.xterm')) {
    window.api.terminal.write(getActiveTerminalId(), text)
    return
  }

  // ç¼–è¾‘å™¨
  if (activeElement?.closest('.monaco-editor')) {
    // é€šè¿‡ Monaco Editor API æ’å…¥
    const editor = getActiveMonacoEditor()
    if (editor) {
      const position = editor.getPosition()
      editor.executeEdits('voice-input', [{
        range: {
          startLineNumber: position.lineNumber,
          startColumn: position.column,
          endLineNumber: position.lineNumber,
          endColumn: position.column
        },
        text: text
      }])
    }
    return
  }

  // å…¶ä»–è¾“å…¥æ¡†
  if (activeElement instanceof HTMLInputElement ||
      activeElement instanceof HTMLTextAreaElement) {
    const start = activeElement.selectionStart || 0
    const end = activeElement.selectionEnd || 0
    const value = activeElement.value
    activeElement.value = value.slice(0, start) + text + value.slice(end)
    activeElement.selectionStart = activeElement.selectionEnd = start + text.length
  }
}
```

### 3. éº¦å…‹é£æƒé™å¤„ç†

```typescript
// src/renderer/services/VoiceInputManager.ts
async requestMicrophonePermission(): Promise<boolean> {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
    stream.getTracks().forEach(track => track.stop())
    return true
  } catch (error) {
    if (error.name === 'NotAllowedError') {
      // ç”¨æˆ·æ‹’ç»äº†æƒé™
      this.showPermissionDeniedDialog()
    }
    return false
  }
}
```

### 4. ç„¦ç‚¹ç®¡ç†

```typescript
// ç¡®å®šå½“å‰æ´»åŠ¨è¾“å…¥åŒºåŸŸ
const getActiveInputTarget = (): 'terminal' | 'editor' | 'search' | null => {
  const activeElement = document.activeElement

  if (activeElement?.closest('.xterm')) {
    return 'terminal'
  }
  if (activeElement?.closest('.monaco-editor')) {
    return 'editor'
  }
  if (activeElement?.closest('.search-input')) {
    return 'search'
  }

  // å›é€€ï¼šæ£€æŸ¥å“ªä¸ªåŒºåŸŸå¯è§
  if (state.activeTerminalId) return 'terminal'
  if (state.activeEditorTabId) return 'editor'

  return null
}
```

---

## å®‰å…¨ä¸éšç§

### æ•°æ®æµå‘è¯´æ˜

| å¼•æ“ | æ•°æ®å¤„ç†ä½ç½® | è¯´æ˜ |
|------|-------------|------|
| ç³»ç»ŸåŸç”Ÿ | æœ¬åœ°è®¾å¤‡ | éŸ³é¢‘å®Œå…¨åœ¨æœ¬åœ°å¤„ç†ï¼Œä¸ä¸Šä¼  |
| Qwen-ASR | é˜¿é‡Œäº‘æœåŠ¡å™¨ | éŸ³é¢‘æµå‘é€åˆ°äº‘ç«¯å¤„ç† |

### å®‰å…¨æªæ–½

1. **éº¦å…‹é£æƒé™**
   - é¦–æ¬¡ä½¿ç”¨æ—¶è¯·æ±‚æƒé™
   - æƒé™è¢«æ‹’ç»æ—¶æä¾›æ¸…æ™°çš„è¯´æ˜
   - åœ¨è®¾ç½®ä¸­æ˜¾ç¤ºæƒé™çŠ¶æ€

2. **API Key å®‰å…¨**
   - Qwen API Key å­˜å‚¨åœ¨ electron-store ä¸­
   - ä¸åœ¨æ—¥å¿—ä¸­è¾“å‡º API Key
   - æä¾› API Key éªŒè¯åŠŸèƒ½

3. **ç”¨æˆ·çŸ¥æƒ…æƒ**
   - åœ¨è®¾ç½®ä¸­æ˜ç¡®æ˜¾ç¤ºå½“å‰å¼•æ“çš„æ•°æ®æµå‘
   - åˆ‡æ¢åˆ°äº‘ç«¯å¼•æ“æ—¶æç¤ºç”¨æˆ·
   - é»˜è®¤ä½¿ç”¨æœ¬åœ°å¼•æ“ä¿æŠ¤éšç§

---

## å‚è€ƒèµ„æº

- [macOS Speech Framework](https://developer.apple.com/documentation/speech)
- [Windows Speech Recognition](https://docs.microsoft.com/en-us/windows/apps/design/input/speech-recognition)
- [é˜¿é‡Œäº‘ Qwen-ASR æ–‡æ¡£](https://help.aliyun.com/zh/model-studio/qwen-asr-realtime)
- [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
